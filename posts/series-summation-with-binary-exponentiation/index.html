<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#ffffff name=theme-color><meta content=#da532c name=msapplication-TileColor><link href=/icons/site.webmanifest rel=manifest><link color=#5bbad5 href=/icons/safari-pinned-tab.svg rel=mask-icon><link href=/icons/favicon.ico rel=icon sizes=16x16 type=image/png><link href=/icons/favicon.ico rel=icon sizes=32x32 type=image/png><link href=/icons/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link crossorigin href=https://cdn.jsdelivr.net/npm/galleria@1.6.1/dist/themes/folio/galleria.folio.min.css integrity=sha384-+rY0QD+LRnTOquDMzGa9lXU6jIwdiQuwCJQ2cdcW0qeP/0UbjQCZlXnRsUMA+9pH rel=stylesheet><link crossorigin href=https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.1/css/academicons.min.css integrity=sha384-FIue+PI4SsI9XfHCz8dBLg33b0c1fMJgNU3X//L26FYbGnlSEfWmNT7zgWc2N9b6 rel=stylesheet><link integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css rel=stylesheet><link href=https://srayan.in/deep-thought.css rel=stylesheet><title>
    
Srayan | Calculating Series Sums with Binary Exponentiation

  </title><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs rel=stylesheet><script crossorigin defer integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js></script><script crossorigin defer integrity=sha384-jiBVvJ8NGGj5n7kJaiWwWp9AjC+Yh8rhZY3GtAX8yU28azcLgoRo4oukO87g7zDT src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js></script><body><nav aria-label="section navigation" class=navbar role=navigation><div class=container><div class=navbar-brand><a class="navbar-item is-size-5 has-text-weight-bold" href=https://srayan.in>Srayan</a><a class="navbar-burger burger" aria-expanded=false aria-label=menu data-target=navMenu role=button> <span aria-hidden=true></span> <span aria-hidden=true></span> <span aria-hidden=true></span> </a></div><div class=navbar-menu id=navMenu><div class="navbar-end has-text-centered"><a class="navbar-item has-text-weight-semibold" href=https://srayan.in/> Home </a><a class="navbar-item has-text-weight-semibold" href=https://srayan.in/posts> Posts </a><a class=navbar-item data-target=#search-modal id=nav-search title=Search> <span class=icon> <i class="fas fa-search"></i> </span> </a><a title="Switch to dark theme" class=navbar-item id=dark-mode style=width:0;height:0;overflow:hidden> </a></div></div></div></nav><section class=section><div class=container><div class=columns><div class="column is-8 is-offset-2"><article class=box><h1 class=title>Calculating Series Sums with Binary Exponentiation</h1><p class=subtitle>Exploring extended applications of binary exponentiation in algorithmic problems<div class="columns is-multiline is-gapless"><div class="column is-8"><span class="icon-text has-text-grey"> <span class=icon> <i class="fas fa-user"></i> </span> <span>Srayan published on</span> <span class=icon> <i class="far fa-calendar-alt"></i> </span> <span><time datetime=2025-03-09>March 09, 2025</time></span> </span></div><div class="column is-4 has-text-right-desktop"><span class="icon-text has-text-grey"> <span class=icon> <i class="far fa-clock"></i> </span> <span>13 min,</span> <span class=icon> <i class="fas fa-pencil-alt"></i> </span> <span>2512 words</span> </span></div><div class=column></div><div class="column has-text-right-desktop"></div></div><div class="content mt-2"><p>The original discussion was posted as a Codeforces Blog entry <a rel="noopener nofollow noreferrer" href=https://codeforces.com/blog/entry/122195 target=_blank>here</a>.<p>I could not find any article or blog on this idea, and felt having one could be helpful to many. There might be unwanted errors, so please feel free to to share any suggestions, corrections or concerns. For those who are unware of Binary Exponentiation, <a rel="noopener nofollow noreferrer" href=https://cp-algorithms.com/algebra/binary-exp.html target=_blank>this CP-Algorithms article</a> or <a href="https://youtu.be/L-Wzglnm4dM?si=VL1jTQI537JWwJ4-" rel="noopener nofollow noreferrer" target=_blank>this video by Errichto</a> can help get familiar with it.<h4 id=introduction>Introduction</h4><p>Now that we know the idea behind binary exponentiation; let us try expanding the idea. Say, we break the problem into two parts, $L$ and $R$, such that, once we have both the results, combining them gives us our final answer as $ans = L \odot R$, where $\odot$ is an <em>associative binary operator.</em> If we can find $R$ as a function of $L$ as in $R = f(L)$ fast enough, say $O(X)$, then our final answer can be found in $O(X \cdot log(n))$.<p>The idea is simple enough, so we now have a look at some simple examples. For the sake of simplicity we assume problem size $n$ is of form $2^k$ , $k \in \mathbb{Z}$ .<h4 id=example-1-calculating-a-n><strong>Example 1:</strong> Calculating $a^n$</h4><p>We are starting from the simplest example. We know that $ans = \underbrace{a \cdot a \dots \cdot a \cdot a }_\text{ n times}$. If we take $R = f(L) = L$, where $L = a^{n/2}$; we can find $R$ in $O(1)$ and build our answer as -<p>$\newline$</p><script type="math/tex;mode=display">ans = \underbrace{\underbrace{\dots \dots \dots}_{L} \odot \underbrace{\dots \dots \dots}_{R = f(L)}}_{\text{L}^{\prime}} \odot \underbrace{\dots \dots \dots \dots \dots \dots \dots}_{\text{R}^{\prime} = f(\text{L}^{\prime})} \; \odot \dots \dots</script><p>We are able to compute $R'$ directly from $L'$, unlike other methods such as RMQ or Binary Lifting, where we build our answer from already calculated $L$ and $R$ on independent smaller ranges to later combine them to compute the answer for the bigger range.<p><strong>Time Complexity:</strong> Finding $R = f(L)$ is $O(1)$, so total time complexity is $O(log(n))$. <br><h4 id=implementation>Implementation</h4><p>The below function only works if $n$ is even. One simple way to handle the odd case is to break the expression as $a^n = a \cdot a^{n-1}$. We can get the answer for $a^{n-1}$ because it's even ans whether $n$ is even or odd, in $\leq 2$ steps $n$ definitely gets halved which ensures that the time complexity remains $O(log(n))$.<pre class=language-cpp data-lang=cpp style=color:#fdf4c1aa;background-color:#282828><code class=language-cpp data-lang=cpp><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>binexpo</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>a</span><span>,</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>n</span><span>)
</span><span>{
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>== </span><span style=color:#d3869b>1</span><span>) </span><span style=color:#fa5c4b>return</span><span> a;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>% </span><span style=color:#d3869b>2</span><span>) </span><span style=color:#fa5c4b>return</span><span> a </span><span style=color:#fe8019>* </span><span style=color:#fdf4c1>binexpo(a, n </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>; </span><span style=color:#928374;font-style:italic>// this line happen only #SetBits times as on every step n is halving
</span><span>    </span><span style=color:#fa5c4b>int</span><span> L </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>binexpo(a, n </span><span style=color:#fe8019>/ </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>int</span><span> R </span><span style=color:#fe8019>=</span><span> L;
</span><span>    </span><span style=color:#fa5c4b>return</span><span> R </span><span style=color:#fe8019>*</span><span> L;    
</span><span>}
</span></code></pre><h4 id=example-2-summation-of-gp-series><strong>Example 2:</strong> Summation of GP Series</h4><p>Considering a standard GP series, we find its summation as<p>$\newline$<p>$$ans = 1 + r + r^{2} \dots r^{n-1} = \frac{r^{n}-1}{r-1}$$<p>If we have to find the summation under arbitrary MOD then it's not necessary that $(r-1)^{-1}$ exists, and so we alternatively express our sum as</p><script type="math/tex;mode=display">ans = \underbrace{1 + r + r^{2} \dots r^{ \frac{n-1}{2} } }_\text{L} + \underbrace{r^{ \frac{n}{2} } + \dots + r^{n-1}}_\text{R}</script><p>which gives $R = f(L) = r^{\frac{n}{2}} \cdot L$.<p>To handle the case for odd $n$ during implementation, we can break series as<p>$\newline$<p>$ans = 1 + a \cdot \underbrace{(1 + a + a^2 + \dots + a^{n-2})}_\text{say sum is S}$<p>We can find $S$ as $(n - 1)$ is even, and final answer will be $= 1 + a \cdot S$.<p><strong>Time Complexity:</strong> Computing $R = f(L)$ is $O(log(n))$, so our total time complexity becomes $O(log(n)^{2})$. But we can calculate powers of $r$ along with our series, so we restrict the final time complexity to $O(log(n))$.<h4 id=implementation-1>Implementation</h4><p>Naive Approach ($O(log(n)^{2})$)<pre class=language-cpp data-lang=cpp style=color:#fdf4c1aa;background-color:#282828><code class=language-cpp data-lang=cpp><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>binexpo</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>x</span><span>,</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>n</span><span>){</span><span style=color:#928374;font-style:italic>/* above code goes here */</span><span>}
</span><span>
</span><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>GP</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>r</span><span>, </span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>n</span><span>)
</span><span>{
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>== </span><span style=color:#d3869b>1</span><span>)
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>1</span><span>;
</span><span>
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>% </span><span style=color:#d3869b>2</span><span>)
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>1 </span><span style=color:#fe8019>+</span><span> r </span><span style=color:#fe8019>* </span><span style=color:#fdf4c1>GP(r, n </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>
</span><span>    </span><span style=color:#fa5c4b>int</span><span> L </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>GP(r, n </span><span style=color:#fe8019>/ </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>int</span><span> R </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>binexpo(r, n </span><span style=color:#fe8019>/ </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>) </span><span style=color:#fe8019>*</span><span> L;
</span><span>    </span><span style=color:#fa5c4b>return</span><span> L </span><span style=color:#fe8019>+</span><span> R;
</span><span>}
</span></code></pre><p>Now, applying our optimization, we compute { $ { r^n ,1 + r \dots + r^{n-1} } $ } together for a final time complexity of $O(logn)$<pre class=language-cpp data-lang=cpp style=color:#fdf4c1aa;background-color:#282828><code class=language-cpp data-lang=cpp><span style=color:#928374;font-style:italic>// {r^n, 1 + r + r^2 ... r^(n-1)}
</span><span>pair<</span><span style=color:#fa5c4b>int</span><span>, </span><span style=color:#fa5c4b>int</span><span>> </span><span style=color:#8ec07c>GP</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>r</span><span>, </span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>n</span><span>)
</span><span>{
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>== </span><span style=color:#d3869b>1</span><span>)
</span><span>        </span><span style=color:#fa5c4b>return </span><span>{r, </span><span style=color:#d3869b>1</span><span>};
</span><span>
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>& </span><span style=color:#d3869b>1</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>auto </span><span>[x, y] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>GP(r, n </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>        </span><span style=color:#fa5c4b>return </span><span>{r </span><span style=color:#fe8019>*</span><span> x, </span><span style=color:#d3869b>1 </span><span style=color:#fe8019>+</span><span> r </span><span style=color:#fe8019>*</span><span> y};
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>auto </span><span>[x, L] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>GP(r, n </span><span style=color:#fe8019>/ </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>int</span><span> R </span><span style=color:#fe8019>=</span><span> x </span><span style=color:#fe8019>*</span><span> L;
</span><span>    </span><span style=color:#fa5c4b>return </span><span>{x </span><span style=color:#fe8019>*</span><span> x, R </span><span style=color:#fe8019>+</span><span> L};
</span><span>}
</span></code></pre><p>We can use a similar idea for calculating GP series of matrices $= I + A + A^2 + \dots + A^{n-1}$. Just like integers under modulo, we can't always guarantee $(A-I)^{-1}$ exists.<p><strong>Contest Example:</strong> In <a rel="noopener nofollow noreferrer" href=https://atcoder.jp/contests/abc293/tasks/abc293_e target=_blank>AtCoder ABC 293 Task E</a> the task is to just compute the sum of a GP series.<h4 id=example-3-summation-of-ap-gp-series><strong>Example 3:</strong> Summation of AP-GP series</h4><p>We start by considering the simple series $\displaystyle r + 2 \cdot r^2 + 3 \cdot r^3 \dots + (n-1)\cdot r^{n-1} = \sum\limits_{i=0}^{n-1} i\cdot r^i$. For this we express the summation as below<p><script type="math/tex;mode=display">$$ans = \underbrace{r + 2 \cdot r^2 + \dots + (\frac{n}{2}-1) \cdot r^{ \frac{n}{2}-1 }}_{L} + \underbrace{ \frac{n}{2} \cdot r^{\frac{n}{2}} + \dots + (n-1) \cdot r^{n-1}}_{R} $$</script> Now we solve for $R = f(L)$.<h5 id=solution-for-r-as-a-function-of-l>Solution for R as a function of L</h5><p>$$R = (\frac{n}{2} + 0) \cdot r^{\frac{n}{2}} + (\frac{n}{2} + 1) \cdot r^{\frac{n}{2}+1} + \dots + (\frac{n}{2} + i) \cdot r^{\frac{n}{2}+i} + \dots + (\frac{n}{2} + \frac{n}{2}-1) \cdot r^{\frac{n}{2} + \frac{n}{2}-1}$$</p><script type="math/tex;mode=display">\small{\implies R = \frac{n}{2} \cdot \left( r^{\frac{n}{2}} + r^{\frac{n}{2}+1} + \dots + r^{\frac{n}{2}+i} + \dots + r^{n-1} \right) + r^{\frac{n}{2}} \cdot \underbrace{\left( 0 \cdot r^{0} + 1 \cdot r^{1} + \dots + i \cdot r^{i} + \dots + \left(\frac{n}{2}-1\right) \cdot r^{\frac{n}{2}-1} \right)}_{\text{L}}}</script><p>$$\implies R = r^{\frac{n}{2}} \cdot \left( \frac{n}{2} \cdot \underbrace{\left( 1 + r^{1} + \dots + r^{i} + \dots + r^{\frac{n}{2}-1} \right)}_{\text{GP series}} + L \right)$$<p>We shall call this GP series as $L_{0}$, whose sum we can already calculate efficiently. Hence,<p>$$R = r^{\frac{n}{2}} \cdot \left( \frac{n}{2} \cdot L_{0} + L \right)$$<p>$$\implies R = f(L_{0},L) = r^{\frac{n}{2}} \cdot \left( \frac{n}{2} \cdot L_{0} + L \right)$$<p>To handle the odd case during implementation, we express summation as:<p>$\newline$<p>$$sum = r + 2\cdot r^2 + \dots + (n-1) \cdot r^{n-1}$$ $$= \left(r + r^2 + \dots + r^i + \dots + r^{n-1} \right) + \left( r^2 + 2\cdot r^3 + \dots + (i-1)\cdot r^{i-1} + \dots + (n-2)\cdot r^{n-1} \right)$$</p><script type="math/tex;mode=display">$$= r \cdot \underbrace{\left(1 + r^1 + \dots + r^i + \dots + r^{n-2} \right)}_{\text{X}} + r \cdot \underbrace{\left( r^1 + 2\cdot r^2 + \dots + i\cdot r^i + \dots + (n-2)\cdot r^{n-2} \right)}_{\text{Y}}$$</script><p>We can get $X$ and $Y$ because they are of even length, and our final answer will be $= r \cdot X + r \cdot Y$ .<p><strong>Time Complexity:</strong> To get $R$ we need to solve $L_{0}$ which takes $O(log(n))$ so total will be $O(log(n)^2)$, but we can calculate powers of $r$, $L_{0}$ and $L$ together which makes total time $O(log(n))$.<h4 id=implementation-2>Implementation</h4><pre class=language-cpp data-lang=cpp style=color:#fdf4c1aa;background-color:#282828><code class=language-cpp data-lang=cpp><span style=color:#928374;font-style:italic>// {r^n , 1+r+r^2 ... + r^(n-1) , 0 + r + 2r^2 + ... + (n-1)r^(n-1) }
</span><span>array<</span><span style=color:#fa5c4b>int</span><span>, </span><span style=color:#d3869b>3</span><span>> </span><span style=color:#8ec07c>APGP</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>r</span><span>, </span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>n</span><span>)
</span><span>{
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>== </span><span style=color:#d3869b>1</span><span>)
</span><span>        </span><span style=color:#fa5c4b>return </span><span>{r, </span><span style=color:#d3869b>1</span><span>, </span><span style=color:#d3869b>0</span><span>};
</span><span>
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>& </span><span style=color:#d3869b>1</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>auto </span><span>[x, L0, L] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>APGP(r, n </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>        </span><span style=color:#fa5c4b>return </span><span>{r </span><span style=color:#fe8019>*</span><span> x, </span><span style=color:#d3869b>1 </span><span style=color:#fe8019>+</span><span> r </span><span style=color:#fe8019>*</span><span> L0, r </span><span style=color:#fe8019>*</span><span> L0 </span><span style=color:#fe8019>+</span><span> r </span><span style=color:#fe8019>*</span><span> L};
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>auto </span><span>[x, L0, L] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>APGP(r, n </span><span style=color:#fe8019>/ </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>int</span><span> R0 </span><span style=color:#fe8019>=</span><span> x </span><span style=color:#fe8019>*</span><span> L0;
</span><span>    </span><span style=color:#fa5c4b>int</span><span> R </span><span style=color:#fe8019>=</span><span> x </span><span style=color:#fe8019>* </span><span>(n </span><span style=color:#fe8019>/ </span><span style=color:#d3869b>2 </span><span style=color:#fe8019>*</span><span> L0 </span><span style=color:#fe8019>+</span><span> L);
</span><span>    </span><span style=color:#fa5c4b>return </span><span>{x </span><span style=color:#fe8019>*</span><span> x, L0 </span><span style=color:#fe8019>+</span><span> R0, L </span><span style=color:#fe8019>+</span><span> R};
</span><span>}
</span></code></pre><p><script type="math/tex;mode=display">For any generic AP-GP series $\sum_{i=0}^{n-1} ( a + i \cdot b ) \cdot r^i = a \cdot \underbrace{\sum_{i=0}^{n-1} r^i}_{{L0}} + b \cdot \underbrace{\sum_{i=0}^{n-1} i \cdot r^i}_{{L}} = a \cdot L_{0} + b \cdot L$, where both are being calculated with single function call.</script> <a rel="noopener nofollow noreferrer" href=https://atcoder.jp/contests/abc129/tasks/abc129_f target=_blank>AtCoder ABC 129 task F</a> is a good practice example for the ideas in the blog.<h4 id=generalising-the-above-series-summations>Generalising the above series summations</h4><p>Now, let us consider $\displaystyle S(n,m) = ‎‎\sum\limits_{i=0}^{n-1} i^m \cdot r^i$. Then we would have GP $= S(n,0)$ and AP-GP $= S(n,1)$. Hence,<p>$\newline$</p><script type="math/tex;mode=display">\displaystyle = \underbrace{r + 2^m \cdot r^2 + \dots + \left(\frac{n}{2}-1\right)^{m} \cdot r^{\frac{n}{2}-1}}_{L(m,n/2)} + \underbrace{\left(\frac{n}{2}\right)^{m} \cdot r^{\frac{n}{2}} + \dots + (n-1)^m \cdot r^{n-1}}_{R(m,n/2)}</script><p>Here $L_{m,\frac{n}{2}} = S(\frac{n}{2},m)$. Then, $S(n,m) = L_{m,\frac{n}{2}} + R_{m,\frac{n}{2}}$, We need to compute $R_{m,\frac{n}{2}}$.<p>$\newline$<p>$$\displaystyle R_{m,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( (\frac{n}{2})^m + (\frac{n}{2}+1)^m \cdot r + \dots + (\frac{n}{2} + i)^m \cdot r^i + \dots (\frac{n}{2} + \frac{n}{2} - 1)^m \cdot r^{\frac{n}{2}-1} \right)$$<p>$$\displaystyle R_{m,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{i=0}^{\frac{n}{2}-1} \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left(\frac{n}{2}\right)^{m-j} \cdot i^j \right) \cdot r^i \right) $$<p>Now, swapping the summations -<p>$$\displaystyle R_{m,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left( \frac{n}{2}\right) ^{m-j} \underbrace{\left( \sum\limits_{i=0}^{\frac{n}{2}-1} i^j \cdot r^i \right)}_\text{L(j,n/2)} \right) $$<p>Finally,<p>$$\displaystyle R_{m,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left( \frac{n}{2}\right) ^{m-j} \cdot L_{j,\frac{n}{2}} \right) = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left( \frac{n}{2}\right) ^{m-j} \cdot S_{\frac{n}{2},j} \right) $$<p>As $j \leq m$ if we calculate everything together, just like above and hence know the value of every $L_{j,\frac{n}{2}}$ without any extra time. We can validate our results for the above illustrated examples of AP and AP-GP series.<h4 id=validating-our-results-against-our-previous-examples>Validating our results against our previous examples</h4><p><strong>Case 1:</strong> for $m=0$ , which is simple GP series<p>$R_{0,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{0} \binom{0}{j} \left( \frac{n}{2}\right) ^{0-j} \cdot L_{j,\frac{n}{2}} \right) = r^{\frac{n}{2}} \cdot L_{0,\frac{n}{2}}$<p><strong>Case 2:</strong> for $m=1$ , which is AP-GP series<p>$R_{1,\frac{n}{2}} = r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{1} \binom{1}{j} \left( \frac{n}{2}\right) ^{1-j} \cdot L_{j,\frac{n}{2}} \right) = r^{\frac{n}{2}} \cdot \left( \left( \frac{n}{2}\right) ^{1} \cdot L_{0,\frac{n}{2}} + L_{1,\frac{n}{2}} \right)$<p>We can now evaluate our original summation as $\displaystyle S_{n,m} = S_{\frac{n}{2},m} + r^{\frac{n}{2}} \cdot \left( \sum\limits_{j=0}^{m} \binom{m}{j} \left( \frac{n}{2}\right) ^{m-j} \cdot S_{\frac{n}{2},j} \right)$.<h5 id=handling-odd-case>Handling Odd Case</h5><p>We have $\displaystyle S_{n,m} = \sum\limits_{i=0}^{n-1} i^m \cdot r^i = r \cdot \left( \sum\limits_{i=1}^{n-2} (i+1)^m \cdot r^i \right)$. However we can only write this if $m>0$ but for $m=0$ first term will not be $0$ but instead be $\displaystyle \lim_{x \to 0} x^x = 1$. So for $m=0$ we will add $1$ instead of $0$, keeping the remainder of the expression same. Thus<p>$$\displaystyle S_{n,m} = r \cdot \left( \sum\limits_{i=0}^{n-2} \sum\limits_{j=0}^{m} \binom{m}{j} i^j \cdot r^i \right)$$<p>And swapping summations</p><script type="math/tex;mode=display">\displaystyle S_{n,m} = r \cdot \left( \sum_{j=0}^{m} \binom{m}{j} \underbrace{\sum_{i=0}^{n-2} i^j \cdot r^i}_{S(n-1,j)} \right) = r \cdot \left( \sum_{j=0}^{m} \binom{m}{j} S_{n-1,j} \right)</script><p>for $m$ > $0$.<p>Hence, we have the final result as:<p>$$ \displaystyle \begin{equation} S_{n,m}= \begin{cases} 1 + r \cdot S_{n-1,0} & \text{if } m=0\ r \cdot \left(\displaystyle \sum\limits_{j=0}^{m} \binom{m}{j} S_{n-1,j} \right) & \text{if } m > 0 \end{cases} \end{equation} $$<p>We can also construct a clean visualization of the even and odd cases using matrix multiplication instead of summation. These are illustrated as below.<h5 id=odd-case>Odd Case</h5><p>Dimensions are: $(m+1,1) = (m+1,m+2) \cdot (m+2,1)$.</p><script type="math/tex;mode=display">\begin{bmatrix} 
    S_{n,0} \\ 
    S_{n,1} \\ 
    \vdots \\ 
    S_{n,m} 
\end{bmatrix} 
=
\begin{bmatrix} 
    1 & \binom{0}{0} & 0 & 0 & \cdots & 0 \\ 
    0 & \binom{1}{0} & \binom{1}{1} & 0 & \cdots & 0 \\ 
    \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\ 
    0 & \binom{m}{0} & \binom{m}{1} & \binom{m}{2} & \cdots & \binom{m}{m} 
\end{bmatrix} 
\cdot 
\begin{bmatrix} 
    1 \\ 
    r \cdot S_{n-1,0} \\ 
    r \cdot S_{n-1,1} \\ 
    \vdots \\ 
    r \cdot S_{n-1,m} 
\end{bmatrix}</script><p>We will return the array $(S_{n,0},S_{n,1}, \dots , S_{n,m}, r^n)$.<h5 id=even-case>Even Case</h5><p>Dimension are: $(m+1,1) = (m+1,m+1) \cdot (m+1,1)$.</p><script type="math/tex;mode=display">$$\begin{bmatrix} R_{0,\frac{n}{2}} \\ R_{1,\frac{n}{2}} \\ \vdots \\ R_{m,\frac{n}{2}} \end{bmatrix} = r^{\frac{n}{2}} \cdot \begin{bmatrix} \binom{0}{0} & 0 & 0 & \cdots & 0 \\ \binom{1}{0} \cdot \frac{n}{2} & \binom{1}{1} & 0 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ \binom{m}{0} \cdot \left(\frac{n}{2}\right)^m & \binom{m}{1} \cdot \left(\frac{n}{2}\right)^{m-1} & \binom{m}{2} \cdot \left(\frac{n}{2}\right)^{m-2} & \cdots & \binom{m}{m} \end{bmatrix} \cdot \begin{bmatrix} L_{0,\frac{n}{2}} \\ L_{1,\frac{n}{2}} \\ L_{2,\frac{n}{2}} \\ \vdots \\ L_{m,\frac{n}{2}} \end{bmatrix}$$</script><p>We will return the array $(L_{0, n/2} + R_{0, n/2},L_{1, n/2} + R_{1, n/2}, \dots , L_{m, n/2} + R_{m, n/2}, r^n)$.<p>In the above cases, whenever we are computing values of $R_{j, n / 2} \hspace{0.25cm} \text{for} \hspace{0.25cm} j \in [0, m]$, they still indeed maintain our original form of $R = f(L)$ as we can express them as<p>$$\vec{R_{\frac{n}{2}}} = f(\vec{L})= r^{\frac{n}{2}} \left( M(n,m) \cdot \vec{L_{\frac{n}{2}}} \right) $$<p><strong>Time Complexity:</strong> To find $R_{j,\frac{n}{2}}$ takes summation of $m$ terms and we do that for every $j \leq m$ which will take $O(m^2)$. So, total complexity is $O(m^2 \cdot log(n)).$<h5 id=implementation-3>Implementation</h5><ol><li><p>Precalculation of $nCr$ takes $O(m^2)$.</p><li><p>During our computations, whenever we have even $n$ we need to compute $(\frac{n}{2})^j$ for each $j \leq m$, which takes $O(m \cdot log(n))$.</p></ol><p>Total complexity $O(m^2 + m \cdot log(n) + m^2 \cdot log(n))$ asymptotically remains same $O(m^2 \cdot log(n))$ .<pre class=language-cpp data-lang=cpp style=color:#fdf4c1aa;background-color:#282828><code class=language-cpp data-lang=cpp><span style=color:#fa5c4b>using </span><span style=color:#8ec07c>int64 </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>long long</span><span>;
</span><span style=color:#fa5c4b>int</span><span> MOD </span><span style=color:#fe8019>= </span><span style=color:#d3869b>1e9</span><span style=color:#fe8019>+</span><span style=color:#d3869b>7</span><span>;
</span><span style=color:#fa5c4b>const int</span><span> M</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1002</span><span>;
</span><span style=color:#fa5c4b>void </span><span style=color:#8ec07c>add</span><span>(</span><span style=color:#fa5c4b>int</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>x</span><span>,</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>y</span><span>){
</span><span>    x</span><span style=color:#fe8019>+=</span><span>y;
</span><span>    </span><span style=color:#fa5c4b>if</span><span>(x</span><span style=color:#fe8019>>=</span><span>MOD)x</span><span style=color:#fe8019>-=</span><span>MOD;
</span><span>}
</span><span style=color:#fa5c4b>void </span><span style=color:#8ec07c>mul</span><span>(</span><span style=color:#fa5c4b>int</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>x</span><span>,</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>y</span><span>){
</span><span>    x </span><span style=color:#fe8019>= </span><span style=color:#d3869b>1</span><span style=color:#fa5c4b>ll </span><span style=color:#fe8019>*</span><span> x </span><span style=color:#fe8019>*</span><span> y </span><span style=color:#fe8019>%</span><span> MOD;
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>int</span><span> ncr[M][M]{</span><span style=color:#d3869b>0</span><span>};
</span><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>nCr</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>nn</span><span>,</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>rr</span><span>){
</span><span> </span><span style=color:#fa5c4b>return</span><span> ncr[nn][rr];   
</span><span>}
</span><span style=color:#928374;font-style:italic>// Precalculate calculate n choose r in O(M^2)
</span><span style=color:#fa5c4b>void </span><span style=color:#8ec07c>nCrinit</span><span>(){
</span><span>    ncr[</span><span style=color:#d3869b>0</span><span>][</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>;
</span><span>    </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> n</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>;n</span><span style=color:#fe8019><</span><span>M;n</span><span style=color:#fe8019>++</span><span>)ncr[n][n]</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>,ncr[n][</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>;
</span><span>    </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> n</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>;n</span><span style=color:#fe8019><</span><span>M;n</span><span style=color:#fe8019>++</span><span>){
</span><span>        </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> r</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>;r</span><span style=color:#fe8019><</span><span>n;r</span><span style=color:#fe8019>++</span><span>){
</span><span>            </span><span style=color:#fdf4c1>add(ncr[n][r],ncr[n</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>][r</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>])</span><span>;
</span><span>            </span><span style=color:#fdf4c1>add(ncr[n][r],ncr[n</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>][r])</span><span>;
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#928374;font-style:italic>// Precalculation of powers of n in O(M * logN)
</span><span style=color:#fa5c4b>using </span><span style=color:#8ec07c>vt </span><span style=color:#fe8019>=</span><span> vector<</span><span style=color:#fa5c4b>int</span><span>>;
</span><span>map&LTint64,vt> ni;
</span><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>n_i</span><span>(int64 </span><span style=color:#fdf4c1>n</span><span>,</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>i</span><span>){
</span><span>    </span><span style=color:#fa5c4b>return</span><span> ni[n][i];
</span><span>}
</span><span style=color:#fa5c4b>void </span><span style=color:#8ec07c>n_iinit</span><span>(int64 </span><span style=color:#fdf4c1>n</span><span>){
</span><span>    </span><span style=color:#fa5c4b>while</span><span>(n</span><span style=color:#fe8019>></span><span style=color:#d3869b>0</span><span>){
</span><span>        </span><span style=color:#fa5c4b>if</span><span>(n</span><span style=color:#fe8019>&</span><span style=color:#d3869b>1</span><span>){
</span><span>            n</span><span style=color:#fe8019>--</span><span>;
</span><span>            </span><span style=color:#fa5c4b>continue</span><span>;
</span><span>        }
</span><span>        vt </span><span style=color:#fdf4c1>x(M)</span><span>; x[</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>;
</span><span>        </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> i</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>;i</span><span style=color:#fe8019><</span><span>M;i</span><span style=color:#fe8019>++</span><span>)x[i] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>1</span><span style=color:#fa5c4b>ll </span><span style=color:#fe8019>*</span><span> x[i</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>] </span><span style=color:#fe8019>* </span><span>(n</span><span style=color:#fe8019>/</span><span style=color:#d3869b>2 </span><span style=color:#fe8019>%</span><span> MOD) </span><span style=color:#fe8019>%</span><span> MOD;
</span><span>        ni[n</span><span style=color:#fe8019>/</span><span style=color:#d3869b>2</span><span>] </span><span style=color:#fe8019>=</span><span> x;
</span><span>        n</span><span style=color:#fe8019>>>=</span><span style=color:#d3869b>1</span><span>;
</span><span>    }
</span><span>    ni[</span><span style=color:#d3869b>1</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>vector<</span><span style=color:#fa5c4b>int</span><span style=color:#fdf4c1>>(M,</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>}
</span><span>
</span><span style=color:#928374;font-style:italic>// Function to generate the series {S(n,0),S(n,1),...,S(n,m),r^n}
</span><span>vector<</span><span style=color:#fa5c4b>int</span><span>> </span><span style=color:#8ec07c>Series</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>r</span><span>,int64 </span><span style=color:#fdf4c1>n</span><span>,</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>m</span><span>)
</span><span>{
</span><span>    </span><span style=color:#fa5c4b>if</span><span>(n</span><span style=color:#fe8019>==</span><span style=color:#d3869b>1</span><span>){
</span><span>        vector<</span><span style=color:#fa5c4b>int</span><span>> </span><span style=color:#fdf4c1>a(m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>        a[</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>;
</span><span>        a[m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span>]</span><span style=color:#fe8019>=</span><span>r;
</span><span>        </span><span style=color:#fa5c4b>return</span><span> a;
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>if</span><span>(n</span><span style=color:#fe8019>&</span><span style=color:#d3869b>1</span><span>){
</span><span>        </span><span style=color:#928374;font-style:italic>// Recursive case for odd n
</span><span>        vector<</span><span style=color:#fa5c4b>int</span><span>>a </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>Series(r,n</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>,m)</span><span>;
</span><span>        vector<</span><span style=color:#fa5c4b>int</span><span>> </span><span style=color:#fdf4c1>S(m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>        </span><span style=color:#fdf4c1>add(S[m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>],</span><span style=color:#d3869b>1</span><span style=color:#fa5c4b>ll </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1> r </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1> a[m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>]</span><span style=color:#fe8019>%</span><span style=color:#fdf4c1>MOD)</span><span>;
</span><span>        </span><span style=color:#fdf4c1>add(S[</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>],</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>        </span><span style=color:#fdf4c1>add(S[</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>],</span><span style=color:#d3869b>1</span><span style=color:#fa5c4b>ll</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>r</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>a[</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>]</span><span style=color:#fe8019>%</span><span style=color:#fdf4c1>MOD)</span><span>;
</span><span>        </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> i</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>;i</span><span style=color:#fe8019><=</span><span>m;i</span><span style=color:#fe8019>++</span><span>){
</span><span>            </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> j</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>;j</span><span style=color:#fe8019><=</span><span>i;j</span><span style=color:#fe8019>++</span><span>){
</span><span>                </span><span style=color:#fdf4c1>add(S[i], </span><span style=color:#d3869b>1</span><span style=color:#fa5c4b>ll </span><span style=color:#fe8019>* </span><span style=color:#fdf4c1>nCr(i,j) </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1> a[j] </span><span style=color:#fe8019>%</span><span style=color:#fdf4c1> MOD)</span><span>;
</span><span>            }
</span><span>            </span><span style=color:#fdf4c1>mul(S[i],r)</span><span>;
</span><span>        }
</span><span>        </span><span style=color:#fa5c4b>return</span><span> S;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// Recursive case for even n
</span><span>    vector<</span><span style=color:#fa5c4b>int</span><span>> L </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>Series(r,n</span><span style=color:#fe8019>/</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>,m)</span><span>;
</span><span>    vector<</span><span style=color:#fa5c4b>int</span><span>> </span><span style=color:#fdf4c1>R(m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> i</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>;i</span><span style=color:#fe8019><=</span><span>m;i</span><span style=color:#fe8019>++</span><span>){
</span><span>        </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> j</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>;j</span><span style=color:#fe8019><=</span><span>i;j</span><span style=color:#fe8019>++</span><span>){
</span><span>            </span><span style=color:#fa5c4b>int</span><span> h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>1</span><span>;
</span><span>            </span><span style=color:#fdf4c1>mul(h,nCr(i,j))</span><span>;
</span><span>            </span><span style=color:#fdf4c1>mul(h,n_i(n</span><span style=color:#fe8019>/</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>,i</span><span style=color:#fe8019>-</span><span style=color:#fdf4c1>j))</span><span>;
</span><span>            </span><span style=color:#fdf4c1>mul(h,L[m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>])</span><span>;
</span><span>            </span><span style=color:#fdf4c1>mul(h,L[j])</span><span>;
</span><span>            </span><span style=color:#fdf4c1>add(R[i],h)</span><span>;
</span><span>        }
</span><span>    }
</span><span>    vector<</span><span style=color:#fa5c4b>int</span><span>> </span><span style=color:#fdf4c1>S(m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    S[m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>1</span><span style=color:#fa5c4b>ll </span><span style=color:#fe8019>*</span><span> L[m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span>] </span><span style=color:#fe8019>*</span><span> L[m</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span>] </span><span style=color:#fe8019>%</span><span> MOD;
</span><span>    </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> i</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>;i</span><span style=color:#fe8019><=</span><span>m;i</span><span style=color:#fe8019>++</span><span>){
</span><span>        </span><span style=color:#928374;font-style:italic>// S[i]=(MOD + R[i] + L[i])%MOD;
</span><span>        </span><span style=color:#fdf4c1>add(S[i],R[i])</span><span>;
</span><span>        </span><span style=color:#fdf4c1>add(S[i],L[i])</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>return</span><span> S;
</span><span>}
</span></code></pre></div></article></div><div class="column is-2 is-hidden-mobile"><aside class=menu style=position:sticky;top:48px><p class="heading has-text-weight-bold">Contents<ul class=menu-list><li><a class="toc is-size-7 is-active" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#introduction id=link-introduction> Introduction </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#example-1-calculating-a-n id=link-example-1-calculating-a-n> Example 1: Calculating $a^n$ </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#implementation id=link-implementation> Implementation </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#example-2-summation-of-gp-series id=link-example-2-summation-of-gp-series> Example 2: Summation of GP Series </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#implementation-1 id=link-implementation-1> Implementation </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#example-3-summation-of-ap-gp-series id=link-example-3-summation-of-ap-gp-series> Example 3: Summation of AP-GP series </a> <ul><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#solution-for-r-as-a-function-of-l id=link-solution-for-r-as-a-function-of-l> Solution for R as a function of L </a></ul><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#implementation-2 id=link-implementation-2> Implementation </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#generalising-the-above-series-summations id=link-generalising-the-above-series-summations> Generalising the above series summations </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#validating-our-results-against-our-previous-examples id=link-validating-our-results-against-our-previous-examples> Validating our results against our previous examples </a> <ul><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#handling-odd-case id=link-handling-odd-case> Handling Odd Case </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#odd-case id=link-odd-case> Odd Case </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#even-case id=link-even-case> Even Case </a><li><a class="toc is-size-7" href=https://srayan.in/posts/series-summation-with-binary-exponentiation/#implementation-3 id=link-implementation-3> Implementation </a></ul></ul></aside></div></div></div></section><section class=modal id=search-modal><div class=modal-background></div><div class=modal-card><header class=modal-card-head><p class=modal-card-title>Search</header><section class=modal-card-body><div class="field mb-2"><div class=control><input placeholder="Search this website." class=input id=search type=search></div></div><div class=search-results><div class=search-results__items></div></div></section></div><button class="modal-close is-large" aria-label=close></button></section><footer class="footer py-4"><div class="content has-text-centered"><p>Copyright <span class=icon-text> <span class=icon> <i class="far fa-copyright"></i> </span> <span>2025</span> </span> <a href=https://github.com/SrayanBhattacharyya>Srayan</a><p>Powered by <span class=icon-text> <span class=icon> <i class="fas fa-power-off"></i> </span> <span>zola</span> </span></div></footer><script crossorigin integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK src=https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js></script><script crossorigin integrity=sha384-QSfwGT8/EU536DKdtyP2D6SLlh8zBaZ0cVkwfrwhqzIU9VCfJT00CLVP5t+HAiYg src=https://cdn.jsdelivr.net/npm/galleria@1.6.1/dist/galleria.min.js></script><script crossorigin integrity=sha384-DwpKI+deZB267+hPKwiOIc5Y2GKsVL0mR6hgz7GgIu7AgAMYqJwcJKY1YBNfhWcY src=https://cdn.jsdelivr.net/npm/galleria@1.6.1/dist/themes/folio/galleria.folio.min.js></script><script crossorigin integrity=sha384-0yWn54pSGtfKCU+skfA69l25VsCw+MZt4LQov3xNRoS7YkAMrFokGgSBnAWSK4pv src=https://cdn.jsdelivr.net/npm/mermaid@8.13.5/dist/mermaid.min.js></script><script crossorigin integrity=sha384-xC3h1+IHXK8seA+8KfT79Z4e0GPsznjXBoMa5nd8ooWKplPyXx92NOmljWxLC/cs src=https://cdn.jsdelivr.net/npm/chart.xkcd@1.1.13/dist/chart.xkcd.min.js></script><script src=https://srayan.in/elasticlunr.min.js></script><script src=https://srayan.in/search_index.en.js></script><script src=https://srayan.in/js/site.js></script><script>const menuBarHeight = document.querySelector("nav.navbar").clientHeight;
  const tocItems = document.querySelectorAll(".toc");
  const navSections = new Array(tocItems.length);

  tocItems.forEach((el, i) => {
    let id = el.getAttribute("id").substring(5);
    navSections[i] = document.getElementById(id);
  })

  function isVisible(tocIndex) {
    const current = navSections[tocIndex];
    const next = tocIndex < tocItems.length - 1 ? navSections[tocIndex + 1]
      : document.querySelectorAll("section.section").item(1);

    const c = current.getBoundingClientRect();
    const n = next.getBoundingClientRect();
    const h = (window.innerHeight || document.documentElement.clientHeight);

    return (c.top <= h) && (n.top - menuBarHeight >= 0);
  }

  function activateIfVisible() {
    for (b = true, i = 0; i < tocItems.length; i++) {
      if (b && isVisible(i)) {
        tocItems[i].classList.add('is-active');
        b = false;
      } else
        tocItems[i].classList.remove('is-active');
    }
  }

  var isTicking = null;
  window.addEventListener('scroll', () => {
    if (!isTicking) {
      window.requestAnimationFrame(() => {
        activateIfVisible();
        isTicking = false;
      });
      isTicking = true;
    }
  }, false);</script>